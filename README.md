## iOS 커리어 스타터 캠프

# 묵찌빠 프로젝트
---

### Timeline
### 1주차
- 월
Step1 : 
    [docs: Step 1 Flowchart 작성 및 README.md에 추가](https://github.com/minsson/ios-rock-paper-scissors/commit/89d4d890134c64fa7bf27a362d5570c58c711ddf) 
    ~ [feat: 사용자 입력에 따른 분기를 처리하는 함수 및 가위바위보 게임 시작 함수 추가](https://github.com/minsson/ios-rock-paper-scissors/commit/63c3fe0e595ea9848c0895b3f875ffc1751accff)

- 화
    Step1 : 
    [feat: 사용자 메뉴 선택을 게임 진행을 위하여 Rps 자료형으로 변환하는 함수 추가](https://github.com/minsson/ios-rock-paper-scissors/commit/5a9c8283c1c296209a50a6c3c8a2ae8745d0cbb7)
    ~ [docs: README.md Step 1 Flowchart가 정상 표시되지 않는 문제 수정](https://github.com/minsson/ios-rock-paper-scissors/commit/8ecd6c5b93a5ee67d84373b07c92a432dd713ae0)

- 수 
    Step1 : 
    [refactor: 가독성 향상을 위한 변수명, 함수명, 파라미터 네임 및 함수 배치 수정 ~](https://github.com/minsson/ios-rock-paper-scissors/commit/85ce471b65d45af381b6d3ee81da5bfc8c07c915)
    Step 2:
    [fix: 묵찌빠 게임에서 사용자와 컴퓨터 간 턴 전환 오류 수정](https://github.com/minsson/ios-rock-paper-scissors/commit/e775675f31e2f1d162e382ca83b120abe766be20)

- 목 
    Step 2:
[refactor: 기능 구현에 필요하지 않는 열거형 구조, 메서드 삭제 및 변수 초기값 수정 ~](https://github.com/minsson/ios-rock-paper-scissors/commit/49c8836502771643d3b7ec811a237d57ac5a96db)
~ [refactor: 가독성 향상을 위한 함수명, 파라미터 네임, 아규먼트 레이블, 변수명 수정](https://github.com/minsson/ios-rock-paper-scissors/commit/9cbb52c3ef19a21f16a7d9d2a43c1d33f3f4d670)

- 금
    Step 2:


---
# Step 1
## 0. 순서도
![Week_2_Step_1_RPS GAME_Flowchart (minsson, sookoong)](https://user-images.githubusercontent.com/96630194/163959698-790a58a1-8795-4842-a164-ac4b44158b54.jpg)

## 1. 커밋 내역
[docs: Step 1 Flowchart 작성 및 README.md에 추가](https://github.com/minsson/ios-rock-paper-scissors/commit/89d4d890134c64fa7bf27a362d5570c58c711ddf)
[feat: 사용자 선택 메뉴 출력을 바탕으로 사용자 메뉴 선택을 입력받는 함수 추가](https://github.com/minsson/ios-rock-paper-scissors/commit/691498f0e2c48b5b99bef78f24ef7ffd9d928c1a)
[feat: 사용자 입력에 따른 분기를 처리하는 함수 및 가위바위보 게임 시작 함수 추가](https://github.com/minsson/ios-rock-paper-scissors/commit/63c3fe0e595ea9848c0895b3f875ffc1751accff)
[feat: 사용자 메뉴 선택을 게임 진행을 위하여 Rps 자료형으로 변환하는 함수 추가](https://github.com/minsson/ios-rock-paper-scissors/commit/5a9c8283c1c296209a50a6c3c8a2ae8745d0cbb7)
[feat: 사용자의 메뉴 선택을 바탕으로 사용자의 가위바위보 값과 컴퓨터의 랜덤 가위바위보 값을 튜플로 결합하여 리턴하는 함…](https://github.com/minsson/ios-rock-paper-scissors/commit/dadf59a30824602d65dbc304ae0166c3ba72d3a5)
[feat: 사용자와 컴퓨터의 가위바위보 값을 입력받아 승, 패, 무승부를 판단하여 반환하는 함수 추가](https://github.com/minsson/ios-rock-paper-scissors/commit/4a2984f9332335923ee1e0cb010aa419f3e3e16b)
[feat: 1) 게임 승, 패, 무승부를 파라미터로 받아 결과를 출력하는 함수 추가, 2) 비기는 경우 게임을 재시작하는 함…](https://github.com/minsson/ios-rock-paper-scissors/commit/425673c4ff1bbeb0605abe643d5b2d46ccf8530b)
[refactor: 가독성 향상을 위한 일부 변수명, 파라미터 네임, 아규먼트 레이블 수정](https://github.com/minsson/ios-rock-paper-scissors/commit/9039b535cea26fc176ea48b4ac43e9b6d4e8b728)
[refactor: 1) 가독성 향상을 위한 일부 변수명, 파라미터 네임, 아규먼트 레이블 수정, 2) 유저 입력을 게임 진행…](https://github.com/minsson/ios-rock-paper-scissors/commit/d6e9aa1565ef0497a2c83250467cffabaf36fa89) 
[docs: Step 1 Flowchart 업로드](https://github.com/minsson/ios-rock-paper-scissors/commit/1f11d3cec6654eae83179536a3b1335b87dd7c5d)
[docs: README.md Step 1 Flowchart 수정](https://github.com/minsson/ios-rock-paper-scissors/commit/43e85290fef3339dbd38088811a82e1ee8273ce6)
[docs: README.md Step 1 Flowchart가 정상 표시되지 않는 문제 수정](https://github.com/minsson/ios-rock-paper-scissors/commit/8ecd6c5b93a5ee67d84373b07c92a432dd713ae0)
[refactor: 가독성 향상을 위한 변수명, 함수명, 파라미터 네임 및 함수 배치 수정](https://github.com/minsson/ios-rock-paper-scissors/commit/85ce471b65d45af381b6d3ee81da5bfc8c07c915)
[refactor: Game 구조체 생성 및 기존 코드 Game 타입 내부로 이동](https://github.com/minsson/ios-rock-paper-scissors/commit/25155ba7e79f7b2f878b301a1ea4b27acd7fcbd8)
[refactor: 사용자의 입력 값을 InputOfRockPaperScissors 타입으로 한번에 반환하는 함수로 수정, e…](https://github.com/minsson/ios-rock-paper-scissors/commit/e379bc1d488b7eaae0342ba58647c3148da123a5)
  
## 2. PR 종합 코멘트 (고민했던 점)

### 2-1. 공통 고민
#### 1) 열거형, 함수 파일 위치
프로젝트가 커질수록 코드 파일을 어떻게 관리하는지도 중요하다고 들었습니다.아직 프로젝트 크키가 너무 작아서 큰 의미가 없을 수 있지만, 일단 나눠보는 게 좋을 것 같다는 생각이 들었습니다.

#### main.swift
게임을 실행하는 함수만 호출했습니다.
#### functions.swift
게임과 관련된 모든 함수를 모아놓았습니다.
#### enums.swift
가위바위보 선택지의 열거형인 `Rps`(Rock Paper Scissors)와 게임 승자(혹은 무승부) 열거형인 `gameWinner`를 정리했습니다. 이와 관련, 사용자 정의 타입은 보통 타입 이름을 파일명으로 정해 파일을 분리한다고 이해했는데, 정의부 코드의 길이가 워낙 짧아 두 개로 나누는 게 애매해보여 한 파일에 넣어보았습니다.

#### 2) 네이밍이 적절한지
네이밍에 대한 고민은 아마 프로그래밍을 하는 한 영원할 것 같다는 생각이 듭니다. 이번 과제에서도 네이밍이 가장 큰 고민거리였던 것 같습니다. 최대한 영어 어법상 자연스러운 함수명과 아규먼트 레이블과 변수명을 생각해보았습니다. 영어 원어민이 아니다보니 전치사 등이 어법상 맞는지 사전을 찾아보기도 했습니다. 그럼에도 아직 네이밍을 더 개선해야할 것 같습니다. 과제를 더 진행해 나가며 더 고민해보겠습니다.

### 2-2. 민쏜의 고민
#### 1) 순서도 (README.md에 포함)
코딩을 하기 전, 순서도를 그리며 충분히 고민한 후 코딩을 진행하는 게 좀 더 좋은 방향이라는 생각이 들었습니다. 수꿍과 많은 시간 투자와 논의를 통해 순서도를 그렸고, 다 잘 돌아갈 것 같아 보였고, 순서도 자체가 아주 잘 작성되었다는 생각이 들었습니다. (사실 디자인에도 신경을 써 더 만족스러웠습니다... 😅)

하지만 정작 코딩을 하면서 순서도와 같은 방식으로는 구현하기가 어렵다는 결론이 나와 무척 아쉬웠습니다. 순서도가 에러를 던지지는 않다보니, 논리가 맞지 않는 것도 맞아보였던 것 같습니다.

순서도를 다시 그리기에는 시간이 부족하고, 다시 그려도 또 잘못된 논리로 그릴 게 우려되어 일단은 코딩에 집중했습니다.Step 2를 하며 다시 순서도를 구상 및 수정해보려고 합니다. 또, 순서도 디자인은 역시 큰 의미가 없다는 생각이 들어, 예쁘게 만드는 것보다는 제대로 된 논리를 우선으로 고민하려고 합니다.

### 2-3. 수꿍의 고민
#### 1) 가위바위보 판정 논리
순서도를 작성하던 중 가위바위보 판정 논리를 짜는데 있어서 궁금증이 생겨 이렇게 질문드립니다!

먼저, 가위 바위 보는 각각 1, 2, 3이라는 숫자로 대신하여 표현되었습니다. 이에 컴퓨터의 임의의 선택 == 바위(2), 사용자의 임의의 선택 == 바위(2) 일 경우 비기는 점을 미루어보아, 컴퓨터의 임의의 선택과 사용자의 선택을 비교하여 둘의 선택, 즉 숫자가 동일하다면 비기는 경우로 처리할 수 있습니다.

하지만, 승패를 다루기 위하여 단순 숫자의 크기를 비교하는 데에는 문제가 생겼습니다. 컴퓨터__가위(1)_ < 사용자_바위(2) 의 경우나, 컴퓨터_바위(2) < 사용자_보(3) 의 경우에 따르면 숫자가 큰 쪽이 이기는 사실을 확인할 수 있었습니다. 그러나, 컴퓨터_보(3) < 사용자_가위(1) 인 경우에는 숫자의 크기는 더욱 작으나 승자는 사용자이기 때문에 단순 크기로 승패를 결정짓는 것은 무리라고 판단하였습니다. 이에 저희는 두 가지 방안을 생각해보았습니다.

##### 방법1)
어차피 가위바위보의 경우의 수는 9가지로, 비긴 경우를 처리한 이후에는 6가지 경우가 남게 되니 이에 승리하는 경우의 수 3가지만 정의하고 나머지를 else나, default로 처리하는 방법이었습니다.

##### 방법2)
두번째 방법은 다음과 같습니다. 인접한 숫자의 경우(예로, 1과 2, 2와 3)에는 숫자의 크기 비교가 게임 승리에 비례하는 관계는 성립되고, 인접하지 않은 1과 3의 경우에는 대소비교를 마친 후 작은 숫자가 게임 승리를 하였음을 확인하였다. 따라서, 컴퓨터의 수와 사용자의 수의 차가 1인 경우에는 대소 비교를 통해 큰 값을 가진 측을 winner로 설정하고, 컴퓨터와 사용자의 수의 차가 1이 아닌 경우에는 대소 비교를 통해 작은 값을 가진 측을 winner로 설정하는 조건을 설정하고자 하였습니다.

좀 더 원활한 이해를 위하여 이를 구현한 순서도를 첨부하였습니다! 첫번째 방법과 두번째 방법 중 어느 것이 더욱 좋은 방법일지 같이 고민해주셨으면 좋겠습니다.

## 3. PR에 대한 리뷰어 종합 코멘트
### 1) 열거형, 함수 파일 위치
파일의 분리의 경우 보통 타입(class, struct, enum 등등)을 기준으로 분리합니다. 현재 파일들 처럼 functions, enums 같은 네이밍 보단 해당 타입명으로 네이밍을 해주시는게 좋습니다. Step2에선 타입을 적극적으로 활용해보시면서 타입을 이용해 분리해보면 좋을 것 같습니다👍

말씀해주신 부분에 대해선 개인적으로는 구현한 코드의 길이와는 상관없이 해당 타입의 속성에 따라서 분리해주는 편입니다. 현재 파일을 예시로 들면 Rps, GameWinner를 각각의 파일로 분리해줄 것 같습니다. 이 부분은 추후에 좀 더 큰 그림의 개념들을 학습하시다 보면 자연스럽게 폴더링, 파일의 분리에 대해서 자신의 기준이 생기기 때문에 너무 걱정하지 않으셔도 될 것 같습니다😊

### 2) 네이밍이 적절한지
네이밍에 대해 정말 많은 고민을 하신것이 너무나도 느껴지는 코드였습니다! 해당 부분에 대한 코멘트들은 아래에 코멘트들로 직접 달아드렸습니다😊

### 3) 순서도
현재 순서도는 마치 코드를 다 짜고 그린 것처럼 명확한 것 같습니다. 하지만 순서도를 명확하고 자세하게 그리는 것도 좋지만, 결국 순서도는 커뮤니케이션을 위한 도식화라고 생각합니다. 따라서 단순하고 쉽게 읽히게 그리는 것도 중요하다고 생각합니다. 현재의 순서도를 봤을 때, 해당 프로젝트를 모르는 사람이 본다고 생각하면 굉장히 보기가 힘들다는 생각이 드는 것 같습니다. 메서드명, 변수명으로 흐름을 명시해주는 것 보다는 누구나 알 수 있는 형식으로 단순하게 작성해주시면 좋을 것 같습니다. 현재 시작 부분들을 바꿔보자면 가위바위보 게임 시작 -> 가위(1), 바위(2), 보(3)! <종료 : 0> : 출력 -> 사용자 입력 -> 0을 입력했을 경우(조건기호) -> 1,2,3을 입력했을 경우(조건기호) -> 이런식으로 누구나 다 알 수 있는 표현들과 대략적인 흐름으로 진행해주시면 좋을 것 같습니다.

또한 모든 메서드들을 서브루틴으로 따로 빼서 해당 메서드의 모든 로직들을 표현해주는 부분은 불필요할 것 같습니다. 순서도에 많은 시간을 투자하기 보다는 순서도의 경우엔 코드를 짜기전에 서로의 커뮤니케이션을 위한 흐름정도만 작성을 하고 코드레벨에 좀 더 시간을 투자하는 것이 좋을 것 같습니다.😊

### 4) 가위바위보 판정 논리
결국에 처리되어지는 결과가 같고, 크리티컬한 문제가 없다는 가정일 때 저라면 비교적 단순한 로직을 선택할 것 같습니다.😊


## 4. 리뷰어 종합 코멘트에 대한 민쏜, 수꿍 답변
### 1.  사용자 정의 타입 사용
Step2에서는 구조체, 열거형 등 다양한 타입들을 적극적으로 사용하여 좀 더 좋은 코드를 구현할 수 있도록 노력하겠습니다.

### 2.  커밋 단위
커밋 단위로 각 기능 하나하나를 구현할 때마다 커밋을 하기로 결정하였습니다. 하지만 코드 구현에 너무 몰입하다보니 다수의 기능들이 한번에 커밋되는 경우를 종종 발견하였습니다. Step2에서는 이를 좀 더 신경써서 진행하고자 합니다.

다만 함수의 경우, commit 시점이 비교적 명확하게 느껴지는 반면, 아래의 커밋과 같이 refactoring 과정을 진행할 때에는 commit 시점이 모호하게 느껴졌습니다. 매번 commit을 하기에는 너무 사소하고 번잡하다 생각합니다. 반면, 아래와 같이 한번에 commit을 진행하니 명료하지 않음을 깨달았습니다. 이에 대하여 좋은 의견 있으신지 여쭈어 보고 싶습니다!

[commit log] [e379bc1](https://github.com/yagom-academy/ios-rock-paper-scissors/commit/e379bc1d488b7eaae0342ba58647c3148da123a5)  
[commit message] refactor: 사용자의 입력 값을 InputOfRockPaperScissors 타입으로 한번에 반환하는 함수로 수정, enum 구조 내 case 추가 및 수정, 매직 넘버/스트링 제거

### 3.  README 작성
Step2에서는 README도 작성하겠습니다!


## 5. 리뷰어 최종 종합 코멘트
피드백 반영 너무 잘해주셨네요!! 두분 다 너무 고생하셨습니다!!😆

커밋단위의 경우엔 답이 없습니다! 팀원 분과 협의하여 정하는게 정답입니다☺️  
하지만 대체적으로 최대한 커밋단위는 작게 가져가는 것이 좋다고 생각해서 개인적으로는 메서드 단위로 하려고 노력합니다👍  
그리고 말씀해주신 커밋같은 경우엔  
refactor: 사용자의 입력 값을 InputOfRockPaperScissors 타입으로 한번에 반환하는 함수로 수정  
refactor: enum 구조 내 case 추가 및 수정  
refactor: 매직 넘버/스트링 제거    
이런식으로 쪼개서 커밋을 했을 것 같습니다ㅎㅎ 아무래도 커밋의 단위가 작으면 작을수록 나중에 오류를 만났을 때 돌아가기 쉽겠죵?!☺️

---

# Step 2
## 0. 순서도
![Week_2_Step_2_RPS GAME_Flowchart (minsson, 수꿍)](https://user-images.githubusercontent.com/99063327/164417079-a0e2f3ba-0fd9-446d-90cb-70bb524ce837.jpg)

## 1. 커밋내역
[feat: 가위바위보 게임 결과에 따라, 가위바위보를 이긴 쪽이 묵찌바 게임의 선공권을 갖도록 수정](https://github.com/minsson/ios-rock-paper-scissors/commit/dc5ad3b837b59b272bc7732e38683290630e547b)
[feat: 기존 가위바위보 게임을 시작하기 위한 start 함수에 묵찌빠 게임을 시작하기 위한 함수를 오버로딩](https://github.com/minsson/ios-rock-paper-scissors/commit/cf2ce392dc2d64ca5d16a877b4fe200326daec12) …
[feat: 묵찌빠 게임 메뉴를 출력 후, 유저의 선택을 입력받아 묵찌빠 타입으로 변환하는 함수 추가](https://github.com/minsson/ios-rock-paper-scissors/commit/7ff89cadb52983ca8851e7799a9d1a75acd30c9c)
[feat: 가위바위보 게임 함수에 묵찌빠 게임을 위한 함수 오버로딩](https://github.com/minsson/ios-rock-paper-scissors/commit/a190dabf9a2249b90bd82e3ee5447d1f4c4240ff) …
[feat: 승자를 선별하기 위하여 가위바위보 게임 함수에 묵찌빠 게임을 위한 함수 오버로딩](https://github.com/minsson/ios-rock-paper-scissors/commit/a6be02376f079ca9af5a001dd2c8a004a93e6c40)
[feat: 묵찌빠 게임 결과 출력용 함수 추가 (기존 가위바위보 함수에 오버로딩)](https://github.com/minsson/ios-rock-paper-scissors/commit/3d37c87211b601d724141fb2e564911812d13ef7)
[feat: 묵찌빠 게임 종료 함수 추가(기존 가위바위보 함수에 오버로딩)](https://github.com/minsson/ios-rock-paper-scissors/commit/0739175d18a314e2ffda0efe96a4c26cb96da2b9)
[fix: 묵찌빠 게임에서 사용자와 컴퓨터 간 턴 전환 오류 수정](https://github.com/minsson/ios-rock-paper-scissors/commit/e775675f31e2f1d162e382ca83b120abe766be20)


## 2. PR 종합 코멘트 (고민했던 점)

### 2-1. 공통 고민
#### 1) 코드 반복 사용 문제 
    가위바위보 게임와 묵찌빠 게임에서 공통적으로 필요로하는 기능들이 많이 발견되었습니다. 이에 저희들은InputOfRockPaperScissors 타입을 받는 부분을 InputOfMukJjiPpa로 받는다면 중복되는 코드를 더 작성할 필요가 없다고 생각했습니다. 

Step 1의 가위바위보 게임을 바탕으로 묵찌빠 게임 기능을 추가하려고 보니, 승/패에 대한 판정 논리를 제외하고는 거의 같은 코드가 반복되는 느낌이 들었습니다. 따라서, 기존 가위바위보 게임의 함수를 최대한 재활용하면 좋을 것이라고 생각했습니다. 즉, 기존 가위바위보 게임용 함수에 묵찌빠 관련 아규먼트를 집어넣고자 했습니다.

다만, 애초에 저희가 생각하는 방향이 가능한지를 확신하지 못하는 만큼, 나름대로 여러가지 방법을 고민하고, 시도해보았는데, 현 시점에서는 모두 실패했습니다. 따라서 과제 제출 시간을 지키기 위해 일단은 기능이라도 구현하기로 했고, 기존 가위바위보 함수를 오버로딩하여 묵찌빠 타입을 넣을 수 있게 만들었습니다.

때문에 중복된 코드의 사용이 매우 많은 상황입니다. 이를 해결하고 싶은데, 전혀 갈피가 잡히지 않아 저희 둘 모두 마음이 답답합니다. 혹시 원래 안되는 걸 계속 시도하고 있는 건지도 모르겠습니다.

아래는 저희가 시도해보거나, 고민해본 내용입니다.

#####  - Generics 사용
처음에 저희는 제너릭을 이용하여 파라미터의 자료형을 유동적으로 처리하는 것이 어떨까 생각이 들었습니다. Swift Proggramming Language - Generics 중 Generic Type과 유사하게 코드를 짜보려고 하였습니다. Struct Game<T> {} 로 구조체를 만들어 안에 들어간 InputOfRockPaperScissors를 T 타입으로 바꾸어보았습니다. 하지만 InputOfRockPaperScissors.rock.rawValue는 2로 잘 인식을 하였던 것이 T.rock.rawValue로는 인식을 하지 못하는 문제를 직면하였습니다. 안에 있던 enum case의 값들을 인식하지 못하는 것 같았습니다. 

간단하게 다음의 코드를 통해 실험을 통해 하나의 가설을 세워보았습니다. Int와 String은 합 연산자의 기능을 수행할 수 있지만, 다른 자료형은 이와 같은 기능이 구현되지 않을 수 있다. 그러므로, 모든 자료형에 공통적으로 구현된 기능이 아니면 제너릭을 사용할 수 없는 것이 아닐까 하는 생각이 들었습니다. 이러한 생각이 맞을지 마이노께 조언을 구하고 싶습니다.



``` swift
func printAddInt(a: Int, b: Int) {
    let value = a + b
    print(value)
}
    
printAddInt(a: 1, b: 2)
 // 3
    
func printAddString(a: String, b: String) {
    let value = a + b
    print(value)
}
    
printAddString(a: "1", b: "2")
// 12
    
func printAddValues<T>(a: T, b: T) {
    let value = a + b
    print(value)
}
    
printAddValues(a: 1, b: 2)
//error : Binary operator '+' cannot be applied to two 'T' operands
```



##### - Tuple 혹은 Dictionary 사용
현재 코드에서는 Game이라는 Struct 안에서 가위바위보와 묵찌빠가 별개의 enum 타입으로 존재합니다. 데이터 타입이 달라 하나의 함수를 같이 사용할 수 없으므로, 아래 예시 코드와 같이 Game이라는 enum 타입을 만들고 가위바위보와 묵찌빠를 그 타입의 case로 두는 방법을 생각해봤습니다.

``` swift
enum Game {
    case rockPaperScissors
    case mukJjiPpa
}
```

##### - class 상속 사용
다음으로, 함수를 상속 받는 방법을 생각해보았습니다. 하나의 클래스에는 가위바위보의 기능을 구현하고, 다른 하나의 클래스에는 묵찌빠 클래스로 지정하여, 가위바위보 클래스를 상속하여 프로퍼티와 메서드를 받으면 어떨까 고민해보았습니다. 하지만 다시 생각을 해본 결과 저희는 기존 가위바위보에서 컴퓨터의 입력값도 받기, 가위바위보 결과에 따라 딱밤 한 대 때리기 등 추가적인 기능을 구현하기 보다는 원래 가지고 있는 메서드가 받는 프로퍼티의 타입을 클래스에 맞게 변경하는 방식이므로, 결국 기존의 가위바위보 내부에 있는 메서드 또한 다시 작성해야함을 인식하였습니다. 즉, 상속을 받아도 어차피 함수를 재정의해줘야 하므로, 저희가 원하는 방향과는 맞지 않다고 판단하였습니다.




### 이번 프로젝트 동안 학습한 키워드
- Enumerations
- Overloading
- Struct
- Optional
- Switch-Case
- Recursive

---

## GroundRule
### 시간
#### 프로젝트에 집중하는 시간
- 09 : 30 ~ 21 : 00
#### 식사 시간
- 점심 12 : 00 ~ 13 : 30
- 저녁 20 : 00 ~ 21 : 00
#### 연락이 어려운 시간
- 없음
#### 휴일
- 민쏜 - 4/20 (수) 예외상황 발생 (10:00~14:00)

### 규칙
#### 커밋
- 최소기능 단위 commit
- 카르마 스타일 따르기 ( 한글로 작성 )
- `feat` = 주로 사용자에게 새로운 기능이 추가되는 경우
- `fix` = 사용자가 사용하는 부분에서 bug가 수정되는 경우
- `docs` = 문서에 변경 사항이 있는 경우
- `style` = 세미콜론을 까먹어서 추가하는 것 같이 형식적인 부분을 다루는 경우 (코드의 변화가 생산적인 것이 아닌 경우)
- `refactor` = production code를 수정하는 경우 (변수의 네이밍을 수정하는 경우)
- `test` = 테스트 코드를 수정하거나, 추가하는 경우 (코드의 변화가 생산적인 것이 아닌 경우)
- `chore` = 별로 중요하지 않은 일을 수정하는 경우 (코드의 변화가 생산적인 것이 아닌 경우)

#### 컨벤션
- Swift API Design Guidelines
- Swift Language Guide

#### 커뮤니케이션
- 디스코드 DM
- 디스코드 단체톡방
- 디스코드 회의실
